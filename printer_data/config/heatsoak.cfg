[gcode_macro HEATSOAK]
description: "Heatsoak with tool preheat + optional tool offset calibration"
# ----------------------------------------------------------------------
# FLOW SUMMARY:
# - Inputs (from Orca / slicer):
#     BED_TEMP, TOOL_TEMP, T0_TEMP, T0_IDLE_TEMP, T1_TEMP, T1_IDLE_TEMP, ...
# - Steps:
#   1) Start bed heating with M140 (no wait).
#   2) If not homed, G28.
#   3) Run an initial QUAD_GANTRY_LEVEL with whatever tool is currently loaded
#      (so toolchanges are safer during soak if gantry was way off).
#   4) Force physical T0 onto the gantry with SELECT_TOOL T=0.
#   5) Figure out which tools are used this print:
#        * Prefer gcode_macro _START_PRINT.tools_used_during_print
#        * Fallback: any Tn_TEMP present in params
#        * Fallback: all toolchanger tools.
#   6) Preheat tools:
#        - For tools used this print:
#            → use Tn_IDLE_TEMP if present,
#              else Tn_TEMP,
#              else TOOL_TEMP,
#              all as integer °C.
#        - For tools not used this print:
#            → heat to 125°C (probe-safe / calibration temp).
#        - For T0 (baseline tool):
#            → M104 Stemp (no T index), because T0 is active.
#   7) If CALIBRATE!=0 (and TC_CALIBRATION_MODE not disabled):
#        → run CALIBRATE_TOOL_OFFSETS CAL_TEMP=125
#   8) Move to CENTER Z=5 and turn on part-cooling fan to help chamber warm.
# ----------------------------------------------------------------------
gcode:
    {% set bedtemp     = params.BED_TEMP|default(60)|int %}
    {% set cal_temp    = 125 %}
    {% set svc_tool    = 0 %}
    {% set tc          = printer.toolchanger %}
    {% set tools_all   = tc.tool_numbers %}
    {% set sp          = printer["gcode_macro _START_PRINT"] if "gcode_macro _START_PRINT" in printer else None %}
    {% set ns          = namespace(used_tools=[]) %}

    # 1) Start bed heating (no wait)
    M140 S{bedtemp}

    # 2) Home if needed
    {% if "xyz" not in printer.toolhead.homed_axes %}
        G28
    {% endif %}

    # 3) Rough QGL with whatever tool is currently active
    M117 Initial QGL (rough)...
    QUAD_GANTRY_LEVEL

    # 4) Force baseline physical T0 onto gantry
    SELECT_TOOL T={svc_tool}

    G28



    # 7) Optional tool offset calibration during heatsoak
    {% set do_cal = params.CALIBRATE|default(1)|int %}
    {% set cal_enabled = 1 %}
    {% if "gcode_macro TC_CALIBRATION_MODE" in printer %}
        {% set cal_enabled = printer["gcode_macro TC_CALIBRATION_MODE"].enabled|int %}
    {% endif %}

    {% if do_cal and cal_enabled %}
        M117 Calibrating tool offsets...
        CALIBRATE_TOOL_OFFSETS CAL_TEMP={cal_temp}
    {% elif do_cal and not cal_enabled %}
        { action_respond_info("HEATSOAK: calibration disabled via TC_CALIBRATION_MODE") }
    {% else %}
        { action_respond_info("HEATSOAK: calibration skipped (CALIBRATE=" ~ do_cal ~ ")") }
    {% endif %}

    # 8) Move to center & blow hot air for soak
    CENTER Z=5
    SELECT_TOOL T={svc_tool}
    M106 S255

[delayed_gcode _HEAT_SOAK_UPDATE]
gcode:
    UPDATE_DELAYED_GCODE ID=_HEAT_SOAK_UPDATE DURATION=0
    {% if printer['gcode_macro PRINT_START'].state %}
        PRINT_START TICK_UPDATE=1
    {% endif %}

[gcode_macro START_PRINT]
# START_PRINT = popup UI + soak timer + run HEATSOAK once + then call _START_PRINT
variable_soak_settings: {
        'enabled':                 True,
        'min_temp_to_trigger':     65,
        'min_duration_to_trigger': 30,
        'soak_seconds_per_minute': 5,
        'soak_time': { 'min': 5, 'max': 45 },
    }
variable_state: {}
gcode:
    {% set SELF    = 'START_PRINT' %}
    {% set SS      = soak_settings %}
    {% set p_stats = printer.print_stats %}

    # Hard reset for a new print
    {% set state = {} if 'BED_TEMP' in params else state %}

    {%- macro ui(msg)  -%}{ action_respond_info('action:prompt_' ~ msg) }{%- endmacro -%}
    {%- macro add(msg) -%}{ ui(msg) }{ ui('show') }{%- endmacro -%}

    {%- macro clamp(val) -%}
        { [ [ SS.soak_time.min * 60.0, val|float(0) ]|max, SS.soak_time.max * 60.0 ]|min }
    {%- endmacro -%}

    {%- macro format_time(sec) -%}
        {%- set s  = sec|int(0) -%}
        {%- set m  = (s % 3600) // 60 -%}
        {%- set s2 = s % 60 -%}
        { m ~ 'm ' ~ s2 ~ 's' }
    {%- endmacro -%}

    {%- macro get_duration_from_name(fname) -%}
        {%- set glob     = printer.printer.__class__.__init__.__globals__ -%}
        {%- set re       = glob.importlib.import_module('re') -%}
        {%- set unit_map = {'d': 86400, 'h': 3600, 'm': 60, 's': 1} -%}
        {%- set matches = re.findall('([0-9]+)([dhms])', fname|string|lower) -%}
        {%- set durations = [] -%}
        {%- for num, unit in matches if unit in unit_map -%}
            {%- set _ = durations.append(num|float(0) * unit_map[unit]) -%}
        {%- endfor -%}
        { durations|sum if durations else -1 }
    {%- endmacro -%}

    {%- macro _show_UI(soak_for) -%}
        { ui('begin heat soaking for ' ~ p_stats.filename.split('_')[0]|default('next print')) }
        { ui('text upcoming print duration: ' ~ format_time(state.get('print_duration', -1))) }
        { ui('text heat soaking for: ' ~ format_time(soak_for)) }
        { ui('button_group_start') }
        {% for step in [15, 10, 5, -15, -10, -5] %}
            { ui('button ' ~ (('+' ~ step|string if step>0 else step|string) ~ ' min') ~ '|' ~ SELF ~ ' ADJUST=' ~ step ~ '|accent--text text--lighten-3') }
        {% endfor %}
        { ui('button_group_end') }
        { ui('button_group_start') }
        { ui('button [ ⏹ ] Cancel|' ~ SELF ~ ' CANCEL=1|error') }
        { ui('button [ ▶ ] Skip|'   ~ SELF ~ ' SKIP=1|success') }
        { add('button_group_end') }
    {%- endmacro -%}

    {%- macro _resume_and_print() -%}
        UPDATE_DELAYED_GCODE ID=_HEAT_SOAK_UPDATE DURATION=0
        M107
        RESTORE_GCODE_STATE NAME=PAUSE_STATE MOVE=0
        SAVE_GCODE_STATE NAME=PAUSE_STATE
        RESUME_BASE
        _START_PRINT {state.params|xmlattr}
        {% set _ = state.clear() %}
    {%- endmacro -%}

    {%- macro _tick() -%}
        {% if printer.pause_resume.is_paused %}
            {% set t_now   = p_stats.total_duration %}
            {% set elapsed = t_now - state.get('last_total', t_now) %}
            {% set remain  = state.get('time_to_soak', 0.0) - elapsed %}
            {% set _ = state.update({'time_to_soak': remain, 'last_total': t_now}) %}
        {% endif %}

        {% set s = state.get('time_to_soak', 0)|int %}
        {% if s <= 0 %}
            { ui('end') }
            { _resume_and_print() }
        {% else %}
            {% set interval = 300 if s > 300 else (60 if s > 60 else (10 if s > 10 else 5)) %}
            UPDATE_DELAYED_GCODE ID=_HEAT_SOAK_UPDATE DURATION={interval}
            { add('text ' ~ format_time(s) ~ ' remaining…') }
        {% endif %}
    {%- endmacro -%}

    # First call: capture params + pause + start heartbeat
    {% if 'params' not in state %}
        {% set print_duration = get_duration_from_name(p_stats.filename)|int %}
        {% set time_to_soak   = clamp(SS.soak_seconds_per_minute * (print_duration / 60.0))|float %}
        {% set _ = state.update({
            'params':         params,
            'print_duration': print_duration,
            'time_to_soak':   time_to_soak,
            'last_total':     p_stats.total_duration,
            'initialized':    False
        }) %}

        SAVE_GCODE_STATE NAME=PAUSE_STATE
        PAUSE_BASE
        UPDATE_DELAYED_GCODE ID=_HEAT_SOAK_UPDATE DURATION=0.1
    {% endif %}

    # One-time init: run HEATSOAK once, then start timer (we do NOT try to count HEATSOAK time)
    {% if not state.get('initialized', False) and 'params' in state and 'TOOL' not in params %}
        {% set _ = state.update({'initialized': True}) %}
        { _show_UI(state.time_to_soak) }

        HEATSOAK {state.params|xmlattr}

        # Reset baseline so the countdown starts cleanly after HEATSOAK
        {% set _ = state.update({'last_total': p_stats.total_duration}) %}
    {% endif %}

    # User interactions + ticks
    {% if 'ADJUST' in params %}
        {% set new_duration = clamp(state.get('time_to_soak', 0.0) + params.ADJUST|float(0.0) * 60.0)|float %}
        {% set _ = state.update({'time_to_soak': new_duration, 'last_total': p_stats.total_duration}) %}
        { _show_UI(new_duration) }
        { _tick() }
    {% elif 'CANCEL' in params %}
        {% set _ = state.clear() %}
        { ui('end') }
        UPDATE_DELAYED_GCODE ID=_HEAT_SOAK_UPDATE DURATION=0
        CANCEL_PRINT
    {% elif 'SKIP' in params %}
        {% set _ = state.update({'time_to_soak': 0}) %}
        { ui('end') }
        { _resume_and_print() }
    {% elif 'TICK_UPDATE' in params and 'params' in state %}
        { _tick() }
    {% endif %}

    SET_GCODE_VARIABLE MACRO={SELF} VARIABLE=state VALUE="{state}"

[gcode_macro PART_AREA]
variable_colors:{
        'lines':        'cyan',
        'fill':         'gray',
        'background':   'black',
        'bed_frame':    'white',
    }
gcode:
    # ╭───────────────────────────────────── Determine area per polygon ─────────────────────────────────────────╮
    {%- macro polygon_area(poly) -%}
        {%- set n  = poly|length -%}
        {%- set ns = namespace(acc=0) -%}
        {%- for point in poly -%}
            {%- set nextp    = poly[(loop.index0 + 1) % n] -%}
            {%- set ns.acc   = ns.acc + (point[0] * nextp[1] - nextp[0] * point[1]) -%}
        {%- endfor -%}
        {(ns.acc / 2.0)|abs}
    {%- endmacro -%}
    # ╰───────────────────────────────────────────────────────────────────────────────────────────────────────────╯

    # ╭──────────────────────────────────── determine the maximum poly area ──────────────────────────────────────╮
    {%- macro max_polygon_area(objs, areas = []) -%}
        {%- for p in objs|map(attribute='polygon') -%} {% set _ = areas.append(polygon_area(p)) %} {% endfor %}
        {areas|map('float')|list|max}
    {%- endmacro -%}
    # ╰───────────────────────────────────────────────────────────────────────────────────────────────────────────╯

    # ╭────────────────────────────────────────────── build the SVG ──────────────────────────────────────────────╮
    {%- macro draw_buildplate_layout_svg(objs, w, h, pad=10) -%}
        {%- set total_w = (w + pad * 2) -%}
        {%- set total_h = (h + pad * 2) -%}

        {%- set svg_parts = [] -%}
 
        {%- set _ = svg_parts.append('<svg xmlns="http://www.w3.org/2000/svg" width="' ~ total_w|round(0) ~ '" height="' ~ total_h|round(0) ~ '" viewBox="0 0 ' ~ total_w|round(0) ~ ' ' ~ total_h|round(0) ~ '" style="background-color:' ~ colors.background ~ ';">') -%}
        {%- set _ = svg_parts.append('<rect x="' ~ pad ~ '" y="' ~ pad ~ '" width="' ~ w ~ '" height="' ~ h ~ '" fill="none" stroke="' ~ colors.bed_frame ~ '" stroke-width="1" />') -%}
        
        {%- for obj in objs -%}
            {%- set pts = [] -%}
            {%- for p in obj.polygon -%}
                {%- set xv = (p[0] + pad)|round(2) -%}
                {%- set yv = (h - p[1] + pad)|round(2) -%}
                {%- set _ = pts.append(xv ~ ',' ~ yv) -%}
            {%- endfor -%}
            {%- set points_str = pts|join(' ') -%}
            {%- set _ = svg_parts.append('<polygon points="' ~ points_str ~ '" stroke="' ~ colors.lines ~ '" fill="' ~ colors.fill ~ '" stroke-width="1" />') -%}
        {%- endfor -%}
        {%- set _ = svg_parts.append('</svg>') -%}
        { svg_parts|join('') }
    {%- endmacro -%}
    # ╰───────────────────────────────────────────────────────────────────────────────────────────────────────────╯

    {% set objects = printer.exclude_object.objects %}
    {% if objects %}
        {% set bed_x = printer.toolhead.axis_maximum.x|float %}
        {% set bed_y = printer.toolhead.axis_maximum.y|float %}
        { action_respond_info(draw_buildplate_layout_svg(objects, bed_x, bed_y)) }
        { action_respond_info('largest thingy: ' ~ (max_polygon_area(printer.exclude_object.objects)|float / 100)|round(2) ~ 'cm²') }
    {% endif %}

[delayed_gcode _HEATSOAK_BEGIN]
gcode:
    {% set st = printer['gcode_macro START_PRINT'].state %}
    {% if st and 'params' in st %}
        # Run the actual heatsoak + optional PART_AREA SVG
        HEATSOAK {st.params|xmlattr}
        { 'PART_AREA' if 'gcode_macro PART_AREA' in printer else '' }

        # After HEATSOAK completes, check if we've already used up the soak time.
        {% set time_to_soak = st.time_to_soak|default(0)|float %}
        {% set t_idled      = printer.print_stats.total_duration|float %}

        {% if t_idled >= time_to_soak and time_to_soak > 0 %}
            # We have already "run out the clock" during HEATSOAK itself,
            # so tell START_PRINT to skip any remaining soak and move on.
            START_PRINT SKIP=1
        {% endif %}
    {% endif %}

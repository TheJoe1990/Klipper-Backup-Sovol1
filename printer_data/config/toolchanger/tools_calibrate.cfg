[tools_calibrate]
pin: PE12

# XY probing / motion behavior
travel_speed: 100          # how fast to move while probing XY
spread: 10                 # XY distance from center during probing

# Z probing behavior
lower_z: 0.1               # how far below the pin tip we drive the nozzle
speed: 2.5                 # Z speed while probing
lift_speed: 4              # Z lift after each probe
final_lift_z: 4            # final Z lift after calibration

# Sampling behavior
sample_retract_dist: 2
samples_tolerance: 0.15
samples: 3
samples_result: median

# Nozzleâ€“probe calibration settings (for using the built-in Z probe)
probe: probe               # name of your nozzle probe
trigger_to_bottom_z: 3     # distance from probe trigger to mechanical stop

[gcode_macro CALIBRATE_MOVE_OVER_PROBE]
gcode:
    {% if "xyz" not in printer.toolhead.homed_axes %}
        G28
    {% endif %}
    BED_MESH_CLEAR
    G90
    G0 Z3 F10000
    G0 X282.5 Y353 F10000  # your probe position

[gcode_macro CALIBRATE_TOOL_OFFSETS]
description: "Calibrate XY offsets between tools at fixed temperature"
gcode:
    {% set tc        = printer.toolchanger %}
    {% set tools_all = tc.tool_numbers %}
    {% set sp        = printer["gcode_macro _START_PRINT"] if "gcode_macro _START_PRINT" in printer else None %}
    {% set ns        = namespace(to_cal=[]) %}
    {% set svc_tool  = 0 %}
    {% set cal_temp  = params.CAL_TEMP|default(171)|int %}

    {% if sp and sp.tools_used_during_print|length > 0 %}
        {% for tn in sp.tools_used_during_print %}
            {% if tn in tools_all and tn not in ns.to_cal %}
                {% set _ = ns.to_cal.append(tn) %}
            {% endif %}
        {% endfor %}
    {% endif %}

    {% if ns.to_cal|length == 0 %}
        {% for tn in tools_all %}
            {% if tn not in ns.to_cal %}
                {% set _ = ns.to_cal.append(tn) %}
            {% endif %}
        {% endfor %}
    {% endif %}

    {% if svc_tool in tools_all and svc_tool not in ns.to_cal %}
        {% set _ = ns.to_cal.append(svc_tool) %}
    {% endif %}

    { action_respond_info(
        "CALIBRATE_TOOL_OFFSETS: baseline T" ~ svc_tool ~
        ", calibrating tools: " ~ ns.to_cal|map('string')|join(", ")
    ) }

    {% if svc_tool in tools_all %}
        SELECT_TOOL T={svc_tool}
        M104 S{cal_temp}
        { action_respond_info(
            "CALIBRATE_TOOL_OFFSETS: baselining T" ~ svc_tool ~
            " at " ~ cal_temp ~ "C"
        ) }
        CALIBRATE_MOVE_OVER_PROBE
        KOMB
        CALIBRATE_MOVE_OVER_PROBE
        TOOL_LOCATE_SENSOR
        _TC_UPDATE_OFFSETS T={svc_tool} BASELINE=1
        M104 S125
    {% else %}
        { action_respond_info("CALIBRATE_TOOL_OFFSETS: baseline tool T0 not present!") }
    {% endif %}

    {% for tn in ns.to_cal %}
        {% if tn != svc_tool %}
            SELECT_TOOL T={tn}
            M104 S{cal_temp}
            { action_respond_info(
                "CALIBRATE_TOOL_OFFSETS: calibrating T" ~ tn ~
                " vs T" ~ svc_tool ~ " at " ~ cal_temp ~ "C"
            ) }
            CALIBRATE_MOVE_OVER_PROBE
            KOMB
            CALIBRATE_MOVE_OVER_PROBE
            TOOL_CALIBRATE_TOOL_OFFSET
            M104 S125
            _TC_UPDATE_OFFSETS T={tn}
        {% endif %}
    {% endfor %}

[gcode_macro CALIBRATE_NOZZLE_PROBE_OFFSET]
description: "Calibrate Z offset between nozzle and bed probe for the active tool"
gcode:
    {% set probe = printer.tool_probe_endstop.active_tool_probe %}
    CALIBRATE_MOVE_OVER_PROBE
    M109 S171           ; heat enough for consistent nozzle shape
    KOMB                ; clean the nozzle first
    CALIBRATE_MOVE_OVER_PROBE
    TOOL_LOCATE_SENSOR
    TOOL_CALIBRATE_PROBE_OFFSET PROBE="{probe}"
    M104 S0


#####################################################################
# Tool Probe Z-offset storage + apply (per [tool_probe Tn] z_offset)
#####################################################################

[gcode_macro _TC_UPDATE_TOOL_PROBE_Z_OFFSETS]
description: "Save/apply tools_calibrate.last_probe_offset into SVF as probe_z_offset_tN; LOAD_ALL applies to non-baseline tools"
variable_svf_prefix: 'probe_z_offset_'
gcode:
  {% set tc        = printer.toolchanger %}
  {% set tools_cal = printer.tools_calibrate if 'tools_calibrate' in printer else None %}
  {% set sv        = printer.save_variables.variables %}
  {% set load_all  = params.LOAD_ALL|default(0)|int %}
  {% set tn        = params.T|default(tc.tool_number)|int %}
  {% set verbose   = printer["gcode_macro TC_LOGGING"].verbose|int if "gcode_macro TC_LOGGING" in printer else 1 %}

  {% macro apply_probe_z(tool_num, val) %}
    {% set sec = 'tool_probe T' ~ tool_num|string %}
    {% set obj = printer.printer.lookup_object(sec, None) %}
    {% if obj %}
      {% set _ = obj.__setattr__('z_offset', val|float) %}
    {% else %}
      {% if verbose %}
        { action_respond_info("_TC_UPDATE_TOOL_PROBE_Z_OFFSETS: could not find object '" ~ sec ~ "' (ok if SVF-only)") }
      {% endif %}
    {% endif %}
  {% endmacro %}

  {% if tools_cal is none %}
    {% if verbose %}
      { action_respond_info("_TC_UPDATE_TOOL_PROBE_Z_OFFSETS: tools_calibrate not available") }
    {% endif %}

  {% elif load_all %}
    # LOAD_ALL: apply saved z offsets (skip baseline T0)
    {% for t in tc.tool_numbers %}
      {% if t|int != 0 %}
        {% set key = svf_prefix ~ 't' ~ t|string %}
        {% set rec = sv.get(key, {}) %}
        {% set z = rec.get('z', none) if rec is mapping else none %}
        {% if z is not none %}
          { apply_probe_z(t, z|float) }
          {% if verbose %}
            { action_respond_info("_TC_UPDATE_TOOL_PROBE_Z_OFFSETS LOAD_ALL: T" ~ t ~ " z_offset=" ~ ((z|float)|round(4))) }
          {% endif %}
        {% else %}
          {% if verbose %}
            { action_respond_info("_TC_UPDATE_TOOL_PROBE_Z_OFFSETS LOAD_ALL: no saved z_offset for T" ~ t) }
          {% endif %}
        {% endif %}
      {% else %}
        {% if verbose %}
          { action_respond_info("_TC_UPDATE_TOOL_PROBE_Z_OFFSETS LOAD_ALL: skipping T0 (baseline)") }
        {% endif %}
      {% endif %}
    {% endfor %}

  {% elif tn not in tc.tool_numbers %}
    { action_respond_info("_TC_UPDATE_TOOL_PROBE_Z_OFFSETS: invalid tool " ~ tn) }

  {% elif tn|int == 0 %}
    # Never auto-change baseline tool T0 probe offset
    {% if verbose %}
      { action_respond_info("_TC_UPDATE_TOOL_PROBE_Z_OFFSETS: skipping save/apply for T0 (baseline)") }
    {% endif %}

  {% else %}
    {% set lp = tools_cal.last_probe_offset|default(none, true) %}
    {% if lp is none %}
      { action_respond_info("_TC_UPDATE_TOOL_PROBE_Z_OFFSETS: no last_probe_offset available (did TOOL_CALIBRATE_PROBE_OFFSET run?)") }
    {% else %}
      {% set key   = svf_prefix ~ 't' ~ tn|string %}
      {% set prev  = sv.get(key, {}) %}
      {% set old_z = (prev.get('z', 0.0)|float) if prev is mapping else 0.0 %}
      {% set new_z = lp|float %}
      {% set dz    = (new_z - old_z)|float %}

      {% set existing = prev.copy() if prev is mapping else {} %}
      {% set _ = existing.update({'z': new_z}) %}
      SAVE_VARIABLE VARIABLE={key} VALUE="{existing}"

      { apply_probe_z(tn, new_z) }

      { action_respond_info(
          "Tool probe z_offset T" ~ tn ~
          ": old=" ~ (old_z|round(4)) ~
          " -> new=" ~ (new_z|round(4)) ~
          " d=" ~ (dz|round(4))
      ) }
    {% endif %}
  {% endif %}



[gcode_macro TC_CALIBRATE_TOOL_PROBE_Z_OFFSETS]
description: "Calibrate and store per-tool [tool_probe Tn] z_offset. T=<n|all|0,1,2>. Does NOT change T0 (baseline)."
gcode:
    {% set P   = printer %}
    {% set tc  = P.toolchanger %}
    {% set tns = tc.tool_numbers %}
    {% set cur = tc.tool_number %}
    {% set req = params.T|default(cur)|string|lower %}
    {% set queue = [] %}

    {% if tc.status != 'ready' %}
        { action_respond_info("TC_CALIBRATE_TOOL_PROBE_Z_OFFSETS: toolchanger not ready (status=" ~ tc.status ~ ")") }
        G4 P0
    {% endif %}

    {% if P.toolhead.homed_axes|lower != 'xyz' %}
        G28
    {% endif %}

    # Build queue
    {% if req == 'all' %}
        {% for t in tns %}
            {% if t != 0 %}  # never change baseline T0
                {% set _ = queue.append(t) %}
            {% endif %}
        {% endfor %}
    {% else %}
        {% for raw in req.split(',')|map('trim') %}
            {% set t = raw|int(-1) %}
            {% if t in tns and t not in queue and t != 0 %}
                {% set _ = queue.append(t) %}
            {% endif %}
        {% endfor %}
    {% endif %}

    {% if queue|length == 0 %}
        { action_respond_info("TC_CALIBRATE_TOOL_PROBE_Z_OFFSETS: nothing to do (T0 excluded by design)") }
        G4 P0
    {% endif %}

    # Always use T0 as the reference tool to FIND the calibrate pin (as you asked)
    {% if tc.tool_number != 0 %}
        T0
    {% endif %}

    # Move over pin area using your existing macro
    CALIBRATE_MOVE_OVER_PROBE
    TOOL_LOCATE_SENSOR

    # Now loop tools and calibrate their probe offsets
    {% for t in queue %}
        T{t}
        CALIBRATE_MOVE_OVER_PROBE
        TOOL_LOCATE_SENSOR

        {% set probe_name = P.tool_probe_endstop.active_tool_probe if 'tool_probe_endstop' in P else '' %}
        {% if probe_name|string == '' %}
            { action_respond_info("TC_CALIBRATE_TOOL_PROBE_Z_OFFSETS: no active_tool_probe available") }
            G4 P0
        {% endif %}

        TOOL_CALIBRATE_PROBE_OFFSET PROBE="{probe_name}"

        # Save/apply result into SVF (NOT printer.cfg) and apply runtime if possible
        _TC_UPDATE_TOOL_PROBE_Z_OFFSETS T={t}
    {% endfor %}

    M117 Probe z_offsets updated (T0 unchanged)




[gcode_macro TC_LOAD_TOOL_PROBE_Z_OFFSETS]
description: "Load/apply saved tool probe z_offset for all tools from SVF"
gcode:
    _TC_UPDATE_TOOL_PROBE_Z_OFFSETS LOAD_ALL=1



[gcode_macro _TC_UPDATE_OFFSETS]
# ----------------------------------------------------------------------
# FLOW SUMMARY:
# - Reads last XY/Z result from tools_calibrate (tools_cal.last_result).
# - Two modes:
#   1) BASELINE=1:
#       * Stores the probe position (baseline nozzle location) in
#         save_variables under key 'probe_position'.
#       * Does NOT apply gcode offsets.
#       * tn (T=) is just for logging.
#   2) Per-tool mode (BASELINE=0, default):
#       * Stores this tool's offset vs baseline in save_variables under
#         a per-tool key (e.g. offsets_t1, offsets_t2, etc.).
#       * Applies those offsets immediately to the toolchanger tool object.
#   3) LOAD_ALL:
#       * Reloads all saved offsets from save_variables and applies them
#         at startup, useful from PRINT_START or startup macro.
# - Output messages are rounded to 3 decimal places.
# ----------------------------------------------------------------------

description: "Save/apply last tools_calibrate offsets; LOAD_ALL applies saved offsets (T0 never auto-changed except BASELINE)"
variable_svf_prefix: 'offsets_'
gcode:
  {% set tc        = printer.toolchanger %}
  {% set tools_cal = printer.tools_calibrate if 'tools_calibrate' in printer else None %}
  {% set sv        = printer.save_variables.variables %}
  {% set load_all  = params.LOAD_ALL|default(0)|int %}
  {% set tn        = params.T|default(tc.tool_number)|int %}
  {% set baseline  = params.BASELINE|default(0)|int %}
  {% set verbose   = printer["gcode_macro TC_LOGGING"].verbose|int if "gcode_macro TC_LOGGING" in printer else 1 %}

  {% macro set_tool_offset(tool_num, x=None, y=None, z=None) %}
    {% set tool_name = tc.tool_names[tool_num] %}
    {% set tool_obj  = printer.printer.lookup_object(tool_name, None) %}
    {% if tool_obj %}
      {% if x is not none %}{% set _ = tool_obj.__setattr__('gcode_x_offset', x) %}{% endif %}
      {% if y is not none %}{% set _ = tool_obj.__setattr__('gcode_y_offset', y) %}{% endif %}
      {% if z is not none %}{% set _ = tool_obj.__setattr__('gcode_z_offset', z) %}{% endif %}
    {% endif %}
  {% endmacro %}

  {% macro save_dict(key, d) %}
    {% set existing = sv.get(key, {}).copy() if sv.get(key) is mapping else {} %}
    {% set _ = existing.update(d) %}
    SAVE_VARIABLE VARIABLE={key} VALUE="{existing}"
  {% endmacro %}

  {% if load_all %}
    # LOAD_ALL: Apply saved offsets for non-baseline tools (skip T0)
    {% for t in tc.tool_numbers %}
      {% if t|int == 0 %}
        {% if verbose %}
          { action_respond_info("_TC_UPDATE_OFFSETS LOAD_ALL: skipping T0 (baseline)") }
        {% endif %}
      {% else %}
        {% set key    = tc.tool_names[t]|lower|replace('tool ', svf_prefix) %}
        {% set stored = sv.get(key, {}) %}
        {% if stored %}
          {% set x = stored.get('x', 0.0)|float %}
          {% set y = stored.get('y', 0.0)|float %}
          {% set z = stored.get('z', 0.0)|float %}
          { set_tool_offset(t, x, y, z) }
          {% if verbose %}
            { action_respond_info("_TC_UPDATE_OFFSETS LOAD_ALL: T" ~ t ~ " X=" ~ (x|round(3)) ~ " Y=" ~ (y|round(3)) ~ " Z=" ~ (z|round(3))) }
          {% endif %}
        {% else %}
          {% if verbose %}
            { action_respond_info("_TC_UPDATE_OFFSETS LOAD_ALL: no saved offsets for T" ~ t) }
          {% endif %}
        {% endif %}
      {% endif %}
    {% endfor %}

  {% else %}
    {% if tools_cal is none %}
      { action_respond_info("_TC_UPDATE_OFFSETS: tools_calibrate module not available") }

    {% elif tn not in tc.tool_numbers %}
      { action_respond_info("_TC_UPDATE_OFFSETS: invalid tool " ~ tn) }

    {% elif (tn|int == 0) and (baseline|int == 0) %}
      # Never auto-change baseline tool offsets for T0 in per-tool mode
      {% if verbose %}
        { action_respond_info("_TC_UPDATE_OFFSETS: skipping save/apply offsets for T0 (baseline)") }
      {% endif %}

    {% else %}
      {% set lr = tools_cal.last_result|default([0.0, 0.0, 0.0], true) %}
      {% set lp = tools_cal.last_probe_offset|default(0.0, true) %}

      {% if baseline %}
        # BASELINE: allowed for T0 (stores probe_position only; does not apply tool gcode offsets)
        { save_dict('probe_position', {'x': lr[0]|float, 'y': lr[1]|float, 'z': lr[2]|float, 'probe': lp|float, 'tool': tn}) }
        { action_respond_info(
            "Baseline (probe_position) T" ~ tn ~ ": X=" ~ ((lr[0]|float)|round(3)) ~
            " Y=" ~ ((lr[1]|float)|round(3)) ~
            " Z=" ~ ((lr[2]|float)|round(3))
        ) }
      {% else %}
        # Per-tool: save & apply
        {% set key = tc.tool_names[tn]|lower|replace('tool ', svf_prefix) %}
        { save_dict(key, {'x': lr[0]|float, 'y': lr[1]|float, 'z': lr[2]|float, 'probe': lp|float}) }
        { set_tool_offset(tn, lr[0]|float, lr[1]|float, lr[2]|float) }
        { action_respond_info(
            "T" ~ tn ~ " offsets saved/applied: X=" ~ ((lr[0]|float)|round(3)) ~
            " Y=" ~ ((lr[1]|float)|round(3)) ~
            " Z=" ~ ((lr[2]|float)|round(3))
        ) }
      {% endif %}
    {% endif %}
  {% endif %}



[gcode_macro _TC_UPDATE_SHUTTLE_OFFSET]
description: "Save last tools_calibrate result as the 'shuttle' (T-1) offset and show old/new/delta"
variable_svf_key: 'offsets_shuttle'
gcode:
    {% set tools_cal = printer.tools_calibrate if 'tools_calibrate' in printer else None %}
    {% if tools_cal is none %}
        { action_respond_info("_TC_UPDATE_SHUTTLE_OFFSET: tools_calibrate module not available") }
        G4 P0
    {% endif %}

    {% set lr   = tools_cal.last_result|default([0.0, 0.0, 0.0]) %}
    {% set lp   = tools_cal.last_probe_offset|default(0.0) %}
    {% set sv   = printer.save_variables.variables %}
    {% set key  = svf_key %}

    {% set prev  = sv.get(key, {}) %}
    {% set old_x = prev.get('x', 0.0)|float %}
    {% set old_y = prev.get('y', 0.0)|float %}
    {% set old_z = prev.get('z', 0.0)|float %}

    {% set new_x = lr[0]|float %}
    {% set new_y = lr[1]|float %}
    {% set new_z = lr[2]|float %}

    {% set dx = (new_x - old_x)|float %}
    {% set dy = (new_y - old_y)|float %}
    {% set dz = (new_z - old_z)|float %}

    {% set payload = {'x': new_x, 'y': new_y, 'z': new_z, 'probe': lp|float } %}
    {% set payload = "{'x': " ~ (new_x|float) ~
                     ", 'y': " ~ (new_y|float) ~
                     ", 'z': " ~ (new_z|float) ~
                     ", 'probe': " ~ (lp|float) ~ "}" %}
    SAVE_VARIABLE VARIABLE={key} VALUE="{payload}"


    { action_respond_info(
        "Shuttle (T-1) offsets saved: " ~
        "old X=" ~ (old_x|round(3)) ~ " Y=" ~ (old_y|round(3)) ~ " Z=" ~ (old_z|round(3)) ~
        " -> new X=" ~ (new_x|round(3)) ~ " Y=" ~ (new_y|round(3)) ~ " Z=" ~ (new_z|round(3)) ~
        " dX=" ~ (dx|round(3)) ~ " dY=" ~ (dy|round(3)) ~ " dZ=" ~ (dz|round(3))
    ) }


[gcode_macro TC_APPLY_SHUTTLE_OFFSETS]
description: "Apply saved shuttle (T-1) XY offsets via SET_GCODE_OFFSET (used for toolless homing moves)"
gcode:
    {% set sv = printer.save_variables.variables %}
    {% set sh = sv.get('offsets_shuttle', {}) %}
    {% set x  = sh.get('x', 0.0)|float %}
    {% set y  = sh.get('y', 0.0)|float %}

    # We generally do NOT want a Z gcode offset for toolless.
    SET_GCODE_OFFSET X={x} Y={y} Z=0.0 MOVE=0

    { action_respond_info("Applied shuttle offsets: X=" ~ (x|round(3)) ~ " Y=" ~ (y|round(3))) }

[gcode_macro TC_CLEAR_GCODE_OFFSETS]
description: "Clear temporary gcode offsets (use when leaving shuttle/toolless mode)"
gcode:
    SET_GCODE_OFFSET X=0.0 Y=0.0 Z=0.0 MOVE=0

    
[gcode_macro TC_CALIBRATION_MODE]
description: "Enable/disable automatic tool offset calibration during HEATSOAK"
variable_enabled: 1
gcode:
    {% if 'ENABLED' in params %}
        # Explicit set via: TC_CALIBRATION_MODE ENABLED=0 or ENABLED=1
        {% set new = params.ENABLED|int %}
    {% else %}
        # No params: toggle current state
        {% set new = 0 if enabled|int else 1 %}
    {% endif %}

    SET_GCODE_VARIABLE MACRO=TC_CALIBRATION_MODE VARIABLE=enabled VALUE={new}

    {% if new %}
        { action_respond_info("TC_CALIBRATION_MODE: enabled") }
    {% else %}
        { action_respond_info("TC_CALIBRATION_MODE: disabled") }
    {% endif %}

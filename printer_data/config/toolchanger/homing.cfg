# =====================================================================
# TOOLLESS_HOME + homing_override (2026-01-15)
#
# PLAIN ENGLISH (high level):
# - We have two homing modes:
#   A) TOOL-PRESENT: a real tool is mounted -> we can use normal probe-based G28 Z
#   B) TOOLLESS: no tool is mounted -> NO active tool probe exists
#        - probe-based G28 Z will fail ("no active tool probe")
#        - so we home X/Y normally, then Z by "tapping" the PE12 calibration probe
#
# Toolless Z strategy:
# - Klipper won't allow Z motion when Z is unhomed, so we *temporarily* declare
#   a safe kinematic Z using [stepper_z].position_max (this does NOT move the printer).
# - We move above the calibration probe XY.
# - We step Z downward in small increments and stop on ANY CHANGE of PE12 state
#   (pressed OR released), because relying on a specific state was flaky.
# - Once we see a state change, we set kinematic Z to a configurable value that
#   represents "Z at calibration-probe contact".
#
# Notes / constraints:
# - No Jinja "break" in Klipper. We avoid it by doing fixed loops + flagging.
# - We do NOT use SET_ACTIVE_TOOL_PROBE / tool_probe_endstop in TOOLLESS Z.
# - You asked to stop calling it a "dome": we call it "calibration probe".
# =====================================================================


[gcode_macro TOOLLESS_HOME]
description: "Toolless Z homing using the PE12 calibration probe (state-change latch)"
# ---------------------------------------------------------------------
# IMPORTANT:
#   calibration_contact_z is the Z value you want to assign WHEN the
#   calibration probe is contacted. This is NOT necessarily bed Z=0.
#   Set it to whatever your system expects as the reference at contact.
#   (If you don't know yet, start with 0.0 just to prove the routine works,
#    then we will calibrate this properly later.)
# ---------------------------------------------------------------------
variable_calibration_contact_z: 0.0

# Where the shuttle must be for Z tap (your existing calibrated position)
variable_probe_x: 281.6
variable_probe_y: 326.1

gcode:
    # =================================================================
    # PLAIN ENGLISH:
    # - Optionally home X/Y (if requested by AXIS).
    # - For Z:
    #   1) Move to probe XY
    #   2) Set TEMP kinematic Z = stepper_z.position_max
    #   3) Clear the PE12 latch (changed=0)
    #   4) Step down until latch.changed flips to 1 (meaning PE12 changed state)
    #   5) Set kinematic Z = calibration_contact_z
    #   6) Lift and park
    #
    # Why state-change?
    # - We don't trust "must become PRESSED" because of noise / initial state.
    # - Any change means we hit (or released) something; we treat first change
    #   as "contact event" and stop immediately.
    # =================================================================

    {% set axes = params.AXIS|default("")|string|upper %}
    {% set home_all = (axes == "" or axes == "XYZ") %}
    {% set do_x = home_all or ("X" in axes) %}
    {% set do_y = home_all or ("Y" in axes) %}
    {% set do_z = home_all or ("Z" in axes) %}

    {% if not do_z %}
        RESPOND TYPE=echo MSG="TOOLLESS_HOME: Z not requested, done."
        RETURN
    {% endif %}

    # Pull max travel from config so we can start from ANY gantry height
    {% set z_max = printer.configfile.config["stepper_z"]["position_max"]|float %}
    {% set z_min = printer.configfile.config["stepper_z"]["position_min"]|float %}
    {% set z_range = (z_max - z_min)|float %}

    # Position + target Z definition at contact
    {% set probe_x = printer["gcode_macro TOOLLESS_HOME"].probe_x|float %}
    {% set probe_y = printer["gcode_macro TOOLLESS_HOME"].probe_y|float %}
    {% set contact_z = printer["gcode_macro TOOLLESS_HOME"].calibration_contact_z|float %}

    # Motion tuning (override per call if you want)
    {% set xy_f      = params.XY_F|default(12000)|int %}
    {% set step_mm   = params.STEP|default(0.25)|float %}          # per-step downward increment
    {% set step_f    = params.STEP_F|default(240)|int %}           # mm/min for Z steps
    {% set max_extra = params.MAX_EXTRA|default(20.0)|float %}     # extra beyond range as cushion
    {% set backoff   = params.BACKOFF|default(2.0)|float %}        # lift after detecting a change
    {% set lift      = params.LIFT|default(10.0)|float %}          # final lift
    {% set park_x    = params.PARK_X|default(175.0)|float %}
    {% set park_y    = params.PARK_Y|default(175.0)|float %}

    # Safety: require the latch macro + gcode_button
    {% if "gcode_macro CALIBRATION_PROBE_LATCH" not in printer %}
        RESPOND TYPE=error MSG="TOOLLESS_HOME: missing [gcode_macro CALIBRATION_PROBE_LATCH]"
        PAUSE
    {% endif %}
    {% if "gcode_button calibration_probe" not in printer %}
        RESPOND TYPE=error MSG="TOOLLESS_HOME: missing [gcode_button calibration_probe] on PE12"
        PAUSE
    {% endif %}

    # If requested, home Y/X (your existing pattern)
    {% if do_y or do_x %}
        G90
        G28 Y
        G90
        G0 Y175 F{xy_f}
    {% endif %}
    {% if do_x %}
        _SENSORLESS_HOME_X
        G90
        G0 X175 F{xy_f}
    {% endif %}

    # Move above calibration probe
    RESPOND TYPE=echo MSG="TOOLLESS_HOME: moving to calibration probe X{probe_x} Y{probe_y}"
    G90
    G0 X{probe_x} Y{probe_y} F{xy_f}

    # TEMP kinematic Z so Klipper allows Z moves while unhomed
    RESPOND TYPE=echo MSG="TOOLLESS_HOME: setting temporary Z=stepper_z.position_max ({z_max})"
    SET_KINEMATIC_POSITION Z={z_max}

    # Clear latch before we start stepping
    SET_GCODE_VARIABLE MACRO=CALIBRATION_PROBE_LATCH VARIABLE=changed VALUE=0

    # Record initial state for logs (not used for stopping)
    {% set initial_state = printer["gcode_macro CALIBRATION_PROBE_LATCH"].state|int %}
    RESPOND TYPE=echo MSG="TOOLLESS_HOME: latch initial state={initial_state} (0=released, 1=pressed); stopping on ANY change"

    # How far we are allowed to search:
    # - z_range covers full travel; add a bit of cushion (max_extra)
    {% set search_mm = z_range + max_extra %}
    {% set steps = (search_mm / step_mm)|int + 1 %}
    RESPOND TYPE=echo MSG="TOOLLESS_HOME: Z search step={step_mm}mm, max_steps={steps} (search_mm={search_mm})"

    # We cannot "break" in Klipper Jinja, so:
    # - Run full loop, but once we detect change we stop moving (move=0),
    #   while still iterating harmlessly.
    {% set ns = namespace(move=1, hit_step=-1) %}

    {% for i in range(steps) %}
        {% if ns.move == 1 %}
            {% if printer["gcode_macro CALIBRATION_PROBE_LATCH"].changed|int == 1 %}
                {% set ns.move = 0 %}
                {% set ns.hit_step = i %}
                RESPOND TYPE=echo MSG="TOOLLESS_HOME: calibration probe state changed at step {i} -> STOP"
            {% else %}
                G91
                G0 Z-{step_mm} F{step_f}
                G90
            {% endif %}
        {% endif %}
    {% endfor %}

    # If we never saw a state change, fail loudly
    {% if printer["gcode_macro CALIBRATION_PROBE_LATCH"].changed|int != 1 %}
        RESPOND TYPE=error MSG="TOOLLESS_HOME: NO state change detected on PE12 after full search. Check probe alignment/wiring."
        PAUSE
    {% endif %}

    # Back off a bit (helps avoid staying compressed)
    {% if backoff > 0 %}
        G91
        G0 Z{backoff} F1200
        G90
    {% endif %}

    # Establish Z reference at the contact point
    RESPOND TYPE=echo MSG="TOOLLESS_HOME: setting kinematic Z={contact_z} at calibration-probe contact (NOT bed Z0 unless you made it so)"
    SET_KINEMATIC_POSITION Z={contact_z}

    # Lift and park
    G91
    G0 Z{lift} F1200
    G90
    G0 X{park_x} Y{park_y} F{xy_f}



[homing_override]
axes: xyz
gcode:
    # =====================================================================
    # PLAIN ENGLISH EXPLANATION
    #
    # We have two homing modes:
    #
    #   A) TOOL-PRESENT HOMING
    #      - A real tool is physically mounted.
    #      - An active tool probe exists.
    #      - We can use normal probe-based G28 Z.
    #
    #   B) TOOLLESS HOMING (SHUTTLE + PE12 calibration probe)
    #      - No tool is mounted.
    #      - There is NO active tool probe, so probe-based G28 Z fails.
    #      - We home Y/X as normal, then call TOOLLESS_HOME AXIS=Z,
    #        which uses the PE12 calibration probe and stops on ANY state change.
    #
    # Detection:
    #   - We still run DETECT_ACTIVE_TOOL_PROBE with a shuttle baseline selected
    #     (T=-1) and read tool_probe_endstop.active_tool_number if available.
    #   - If it reports -1 => treat as toolless.
    #
    # IMPORTANT:
    #   - We no longer treat "open_probes=0" as fatal.
    #   - Toolless Z does NOT rely on tool_probe_endstop or SET_ACTIVE_TOOL_PROBE.
    # =====================================================================

    {% set p = params|default({}) %}
    {% set home_all = ('X' not in p and 'Y' not in p and 'Z' not in p) %}
    {% set home_x = home_all or ('X' in p) %}
    {% set home_y = home_all or ('Y' in p) %}
    {% set home_z = home_all or ('Z' in p) %}

    # Clear offsets before any homing decisions
    SET_GCODE_OFFSET X=0.0 Y=0.0 Z=0.0

    {% set max_y = printer.configfile.config["stepper_y"]["position_max"]|float %}

    # ------------------------------------------------------
    # 1) Detect whether a tool is mounted
    # ------------------------------------------------------
    # Try to establish a consistent baseline for detection (doesn't hurt if no probes are open)
    SET_ACTIVE_TOOL_PROBE T=-1
    DETECT_ACTIVE_TOOL_PROBE

    {% set detected = -1 %}
    {% if 'tool_probe_endstop' in printer %}
      {% set detected = printer.tool_probe_endstop.active_tool_number|default(-1)|int %}
    {% endif %}

    RESPOND TYPE=echo MSG="Homing: detected_tool={detected}"

    # ======================================================
    # BRANCH B: NO TOOL -> TOOLLESS HOMING
    # ======================================================
    {% if detected == -1 %}
        RESPOND TYPE=echo MSG="No tool -> TOOLLESS homing"

        # Apply shuttle offsets for XY moves in shuttle mode
        TC_APPLY_SHUTTLE_OFFSETS

        # --- Y first (required for your X sensorless pattern) ---
        {% if home_y or home_x %}
            G90
            G28 Y
        {% endif %}

        # --- X sensorless (requires Y already homed) ---
        {% if home_x %}
            G90
            G0 Y{ max_y - 175 } F5000
            _SENSORLESS_HOME_X
            G91
            G0 X-10 F5000
            G0 X-165 F5000
            G90
            G28 Y
        {% endif %}

        # --- Z via PE12 calibration probe ---
        {% if home_z %}
            TOOLLESS_HOME AXIS=Z
        {% endif %}

        # IMPORTANT TODO you mentioned:
        # - After toolless homing, initialize toolchanger so you can select a tool.
        #   We are NOT doing that automatically yet because your tool-present branch
        #   currently needs fixes and we don't want to accidentally assume state.
        #   When you're ready, we'll add:
        #       INITIALIZE_TOOLCHANGER (or your preferred init macro)
        #   here, after toolless Z completes.

    # ======================================================
    # BRANCH A: TOOL PRESENT -> TOOL HOMING
    # ======================================================
    {% else %}
        RESPOND TYPE=echo MSG="Tool T{detected} -> TOOL-PRESENT homing"

        # Initialize toolchanger state based on what was physically detected
        _INITIALIZE_FROM_DETECTED_TOOL
        STOP_TOOL_PROBE_CRASH_DETECTION

        # --- Z-first strategy when a tool is mounted (prevents dock collisions) ---
        {% if home_z %}
            # If probe is already triggered, don't attempt Z homing
            {% if printer.probe.last_query %}
                RESPOND TYPE=error MSG="Homing: probe already triggered; refusing to home Z"
                PAUSE
            {% endif %}

            G90
            G28 Z

            # lift after rough Z
            G91
            G0 Z10 F1200
            G90
        {% endif %}

        # --- Y ---
        {% if home_y or home_x %}
            G90
            G28 Y
        {% endif %}

        # --- X (sensorless, requires Y) ---
        {% if home_x %}
            G90
            G0 Y{ max_y - 175 } F5000
            _SENSORLESS_HOME_X
            G91
            G0 X-10 F5000
            G0 X-165 F5000
            G90
            G28 Y
        {% endif %}

        # --- Final Z at center (optional, only if Z requested) ---
        {% if home_z %}
            {% set random_x = (range(-50, 50) | random) / 10 %}
            {% set random_y = (range(-50, 50) | random) / 10 %}

            G90
            G0 X{175.0+random_x} Y{175.0+random_y} F12000

            G91
            G0 Z5 F1200
            G90

            G28 Z

            G91
            G0 Z5 F1200
            G90

            _ADJUST_Z_HOME_FOR_TOOL_OFFSET
            _APPLY_ACTIVE_TOOL_GCODE_OFFSETS
        {% endif %}
    {% endif %}

    # Cleanup
    M400
    SET_TMC_FIELD STEPPER=stepper_x FIELD=TPWMTHRS VALUE=0
    SET_TMC_FIELD STEPPER=stepper_y FIELD=TPWMTHRS VALUE=0
    SET_TMC_FIELD STEPPER=stepper_x FIELD=en_spreadCycle VALUE=1
    SET_TMC_FIELD STEPPER=stepper_y FIELD=en_spreadCycle VALUE=1




[gcode_macro TC_DEBUG_DETECT_TOOL]
description: "Debug: show tool detection state (does not move)"
gcode:
    SET_ACTIVE_TOOL_PROBE T=-1
    DETECT_ACTIVE_TOOL_PROBE
    RESPOND TYPE=echo MSG="probe.active_tool_number={printer.probe.active_tool_number|default('undef')}"
    {% if 'tool_probe_endstop' in printer %}
        RESPOND TYPE=echo MSG="tool_probe_endstop.active_tool_number={printer.tool_probe_endstop.active_tool_number|default('undef')}"
        RESPOND TYPE=echo MSG="tool_probe_endstop.active_tool_probe={printer.tool_probe_endstop.active_tool_probe|default('undef')}"
    {% else %}
        RESPOND TYPE=echo MSG="tool_probe_endstop not present in printer objects"
    {% endif %}



# ================================================================
# [homing_override] — DEPRECATED / DISABLED on 2025-12-10
# Reason for removal:
#     This homing strategy always homed Y → X first, regardless of
#     tool state. When a tool was on the shuttle AND the gantry was
#     high, the XY moves caused collisions that knocked tools off
#     the docks. We have moved to a Z-first strategy when a tool is
#     detected to avoid collisions.
#
# This entire block is preserved ONLY for reference.
# ================================================================

# [homing_override]
# axes: xyz
# gcode:
#     # Figure out what the user actually asked to home
#     {% set p = params|default({}) %}
#     {% set home_all = ('X' not in p and 'Y' not in p and 'Z' not in p) %}
#     {% set want_z = home_all or ('Z' in p) %}
#
#     # ------------------------------------------------------------------
#     # 1) ALWAYS HOME Y FIRST, THEN X (SENSORLESS), NO MATTER WHAT
#     # ------------------------------------------------------------------
#     SET_GCODE_OFFSET X=0.0 Y=0.0 Z=0.0
#     {% set max_y = printer.configfile.config["stepper_y"]["position_max"]|float %}
#
#     G90
#     G28 Y
#
#     G90
#     G0 Y{ max_y - 175 } F5000
#     _SENSORLESS_HOME_X
#     G91
#     G0 X-10 F5000
#     G0 X-165 F5000
#     G28 Y
#
#     # If the user only asked for X/Y, stop here
#     {% if not want_z %}
#         RESPOND TYPE=echo MSG="Homing complete: Y & X done; Z skipped per request"
#         M400
#         SET_TMC_FIELD STEPPER=stepper_x FIELD=TPWMTHRS VALUE=0
#         SET_TMC_FIELD STEPPER=stepper_y FIELD=TPWMTHRS VALUE=0
#         SET_TMC_FIELD STEPPER=stepper_x FIELD=en_spreadCycle VALUE=1
#         SET_TMC_FIELD STEPPER=stepper_y FIELD=en_spreadCycle VALUE=1
#         RETURN
#     {% endif %}
#
#     # ------------------------------------------------------------------
#     # 2) PREP TOOL-PROBE STATE & DETECT WHAT'S ON THE SHUTTLE
#     # ------------------------------------------------------------------
#     {% set atn = printer.probe.active_tool_number | default(-1) | int %}
#     {% if atn == -1 %}
#         # Use shuttle probe as baseline if nothing is active
#         RESPOND TYPE=echo MSG="No active tool probe; selecting shuttle probe (T=-1) for detection"
#         SET_ACTIVE_TOOL_PROBE T=-1
#     {% endif %}
#
#     DETECT_ACTIVE_TOOL_PROBE
#     {% set detected = printer.probe.active_tool_number | int %}
#
#     # ------------------------------------------------------------------
#     # 3) Z HOMING BRANCH: TOOLLESS VS TOOL
#     # ------------------------------------------------------------------
#
#     {% if detected == -1 %}
#         # ----------------------------
#         # NOTHING ON SHUTTLE → TOOLLESS Z HOMING
#         # ----------------------------
#         RESPOND TYPE=echo MSG="DETECT_ACTIVE_TOOL_PROBE: no tool found → toolless Z homing"
#         # Call your toolless routine *just for Z*
#         TOOLLESS_HOME Z=1
#         RETURN
#
#     {% else %}
#         # ----------------------------
#         # TOOL DETECTED → NORMAL Z HOMING
#         # ----------------------------
#         _INITIALIZE_FROM_DETECTED_TOOL
#         STOP_TOOL_PROBE_CRASH_DETECTION
#
#         {% if printer.probe.last_query %}
#             RESPOND TYPE=echo MSG='Z Probe triggered, cannot home.'
#         {% else %}
#             {% set random_x = (range(-50, 50) | random) / 10 %}
#             {% set random_y = (range(-50, 50) | random) / 10 %}
#
#             G90
#             G0 X{175.0+random_x} Y{175.0+random_y} F12000
#             G28 Z
#             _ADJUST_Z_HOME_FOR_TOOL_OFFSET
#
#             _APPLY_ACTIVE_TOOL_GCODE_OFFSETS
#             M400
#             SET_TMC_FIELD STEPPER=stepper_x FIELD=TPWMTHRS VALUE=0
#             SET_TMC_FIELD STEPPER=stepper_y FIELD=TPWMTHRS VALUE=0
#             SET_TMC_FIELD STEPPER=stepper_x FIELD=en_spreadCycle VALUE=1
#             SET_TMC_FIELD STEPPER=stepper_y FIELD=en_spreadCycle VALUE=1
#         {% endif %}
#     {% endif %}
# ================================================================
# END OF DEPRECATED BLOCK — 2025-12-10
# ================================================================


[gcode_macro _SENSORLESS_HOME_X]
variable_home_current: 0.5
gcode:
    # Always use consistent run_current on A/B steppers during sensorless homing
    {% set RUN_CURRENT_X = printer.configfile.settings['tmc2209 stepper_x'].run_current|float %}
    {% set RUN_CURRENT_Y = printer.configfile.settings['tmc2209 stepper_y'].run_current|float %}    
    SET_TMC_CURRENT STEPPER=stepper_x CURRENT={printer["gcode_macro _SENSORLESS_HOME_X"].home_current}

    # Home
    G28 X
    # Move away
    G91
    G1 X-10 F1200
    
    # Wait just a second… (give StallGuard registers time to clear)
    G4 P1000
    # Set current during print
    SET_TMC_CURRENT STEPPER=stepper_x CURRENT={RUN_CURRENT_X}
    SET_TMC_CURRENT STEPPER=stepper_y CURRENT={RUN_CURRENT_Y}

; Depending on the selected tool at the time of homing, the physical Z endstop position is offset.
; This corrects for that using current tool offset.
[gcode_macro _ADJUST_Z_HOME_FOR_TOOL_OFFSET]
gcode:
      G90 ; absolute mode
      G0 Z10 F1000
      {% set tool = printer.toolchanger.tool %}
      {% if tool %}
         {% set tool_z_offset = printer[tool].gcode_z_offset %}
         {% set probe_z_offset = printer.tool_probe_endstop.active_tool_probe_z_offset %}
         SET_KINEMATIC_POSITION Z={10.0+tool_z_offset|float+probe_z_offset|float}
      {% endif %}

[gcode_macro _APPLY_ACTIVE_TOOL_GCODE_OFFSETS]
gcode:
    ; Apply gcode offsets
    {% set tool = printer.toolchanger.tool %}
    {% if tool %}
      SET_GCODE_OFFSET X={printer[tool].gcode_x_offset} Y={printer[tool].gcode_y_offset} Z={printer[tool].gcode_z_offset}
    {% endif %}

[gcode_macro TOOL_BED_MESH_CALIBRATE]
gcode:
      {% set tool_z_offset = printer[printer.toolchanger.tool].gcode_z_offset %}
      G90 ; absolute mode
      G0 Z10 F1000
      # Bed mesh knows about the probe offset, but not about the tool offset.
      SET_KINEMATIC_POSITION Z={10.0-tool_z_offset|float}
      BED_MESH_CALIBRATE
      G0 Z10 F1000
      SET_KINEMATIC_POSITION Z={10.0+tool_z_offset|float}



[gcode_macro TC_SELECT_DETECTION_PROBE]
description: "Select a usable active tool probe for detection; prefer shuttle (T=-1)"
gcode:
  {% set tpe = printer.printer.lookup_object('tool_probe_endstop', None) %}
  {% if not tpe %}
    RESPOND TYPE=error MSG="TC_SELECT_DETECTION_PROBE: tool_probe_endstop not found"
    PAUSE
  {% endif %}

  {% set open_tools = tpe._query_open_tools()|list %}
  RESPOND TYPE=echo MSG="TC_SELECT_DETECTION_PROBE: open_probes={open_tools|length}"

  # Prefer shuttle probe if it is open/available
  {% set shuttle = None %}
  {% for p in open_tools %}
    {% if p.tool|int == -1 %}
      {% set shuttle = p %}
    {% endif %}
  {% endfor %}

  {% if shuttle %}
    RESPOND TYPE=echo MSG="TC_SELECT_DETECTION_PROBE: selecting shuttle probe (T=-1)"
    {% set _ = tpe.set_active_probe(shuttle) %}
  {% elif open_tools|length == 1 %}
    RESPOND TYPE=echo MSG="TC_SELECT_DETECTION_PROBE: selecting only open probe (T={open_tools[0].tool})"
    {% set _ = tpe.set_active_probe(open_tools[0]) %}
  {% else %}
    RESPOND TYPE=error MSG="TC_SELECT_DETECTION_PROBE: cannot choose probe (open_probes={open_tools|length}). Check shuttle probe pin state."
    PAUSE
  {% endif %}

  RESPOND TYPE=echo MSG="TC_SELECT_DETECTION_PROBE: active_tool_probe={printer.tool_probe_endstop.active_tool_probe|default('None')}, active_tool_number={printer.tool_probe_endstop.active_tool_number|default('undef')}"
